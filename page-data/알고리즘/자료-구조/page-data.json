{"componentChunkName":"component---src-templates-blog-post-js","path":"/알고리즘/자료-구조/","result":{"data":{"site":{"siteMetadata":{"title":"Hannah's Dev Log","author":"Heejin Kim","siteUrl":"https://dev-hannahk.github.io","comment":{"disqusShortName":"","utterances":"dev-hannahk/dev-hannahk.github.io"},"sponsor":{"buyMeACoffeeId":"dev-hannahk"}}},"markdownRemark":{"id":"b90af54a-fdb5-5955-a639-414dd41d3335","excerpt":"데이터: 일반적으로 모든 유형의 정보를 망라하는 용어, 가장 기초적인 수와 문자열로 이뤄진다. 자료구조: 데이터를 조직하는 방법으로, 데이터 조직이 코드의 실행 속도에 미치는 영향이 크다. 1.…","html":"<ul>\n<li>데이터: 일반적으로 모든 유형의 정보를 망라하는 용어, 가장 기초적인 수와 문자열로 이뤄진다.</li>\n<li>자료구조: 데이터를 조직하는 방법으로, 데이터 조직이 코드의 실행 속도에 미치는 영향이 크다.</li>\n</ul>\n<h2 id=\"11-배열-기초-자료-구조\" style=\"position:relative;\"><a href=\"#11-%EB%B0%B0%EC%97%B4-%EA%B8%B0%EC%B4%88-%EC%9E%90%EB%A3%8C-%EA%B5%AC%EC%A1%B0\" aria-label=\"11 배열 기초 자료 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.1 배열: 기초 자료 구조</h2>\n<ul>\n<li>배열은 컴퓨터 과학에서 기초적인 자료 구조 중 하나, 데이터 원소들의 리스트</li>\n<li>배열 같은 자료 구조의 성능을 알려면 코드가 자료 구조와 일반적으로 어떻게 상호작용하는 지 분석해야 한다.</li>\n<li>대부분의 자료 구조는 네 가지 기본 방법을 사용하며 이를 연산이라 부른다.</li>\n</ul>\n<h3 id=\"연산\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%82%B0\" aria-label=\"연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연산</h3>\n<ul>\n<li>읽기: 읽기는 자료 구조 내 특정 위치를 찾아보는 것이다. 배열에서는 특정 인덱스 값을 찾아보는 것을 뜻한다.</li>\n<li>검색: 검색은 자료 구조 내에서 특정 값을 찾는 것이다. 배열에서는 특정 값이 배열에 들어 있는지, 만약 그렇다면 어떤 인덱스에 있는지 알아보는 것을 뜻한다.</li>\n<li>삽입: 삽입은 자료 구조에 새로운 값을 추가하는 것이다. 배열이라면 배열 내에 슬롯을 더 만들어 새 값을 추가하는 것을 뜻한다.</li>\n<li>삭제: 삭제는 자료 구조에서 값을 제거하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻한다.</li>\n</ul>\n<p>연산이 얼마나 “빠른가”를 측정할 때는 순수하게 시간 관점에서 연산이 얼마나 빠른가가 아니라 얼마나 많은 단계(스텝)가 필요한지를 논해야 한다.</p>\n<p>연산의 속도 측정은 연산의 <strong>시간 복잡도</strong> 측정으로도 알려져 있다. (속도, 시간복잡도, 효율성, 성능)</p>\n<h2 id=\"12-읽기\" style=\"position:relative;\"><a href=\"#12-%EC%9D%BD%EA%B8%B0\" aria-label=\"12 읽기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.2 읽기</h2>\n<p>컴퓨터가 배열의 특정 인덱스 있는 값을 읽을 때 한 번의단계로 바노 갈 수 있는 데는 다음과 같은 점들이 복합적으로 작용한다.</p>\n<ol>\n<li>컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.</li>\n<li>각 배열에 저장된 내용은 메모리의 시작 주소다. 따라서 컴퓨터는 손쉽게 시작 주소를 얻는다.</li>\n<li>배열의 인덱스는 0부터 시작한다.</li>\n</ol>\n<h2 id=\"13-검색\" style=\"position:relative;\"><a href=\"#13-%EA%B2%80%EC%83%89\" aria-label=\"13 검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.3 검색</h2>\n<p>배열 검색은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것이다.\n<strong>선형검색</strong>: 컴퓨터가 한 번에 한 셀씩 확인하는 방법</p>\n<h2 id=\"14-검색\" style=\"position:relative;\"><a href=\"#14-%EA%B2%80%EC%83%89\" aria-label=\"14 검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.4 검색</h2>\n<p>배열에 새 데이터를 삽입하는 연산은 배열의 <strong>어디에</strong> 데이터를 삽입하는가에 따라 효율성이 다르다.\n<br/>\n배열의 끝에 삽입할 때에는 딱 한 단계만 필요하다. 하지만 배열의 <strong>맨 처음</strong>이나 <strong>중간</strong>에 데이터를 삽입하면 문제가 달라진다.\n<br/>\n배열 삽입에서 최악의 시나리오, 즉 삽입에 가장 많은 단계가 걸리는 시나리오는 데이터를 배열의 맨 앞에 삽입할 때다. 배열의 앞에 삽입하면 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문이다.</p>\n<p>다시 말해, 원소 N개를 포함하는 배열에서 최악의 시나리오일 때 삽입에는 N+1 단예가 걸린다. N번의 이동(배열의 모든 데이터 원소)과 1번의 삽입으로 배열의 맨 앞에 값을 삽입하기 때문이다.</p>\n<h2 id=\"15-삭제\" style=\"position:relative;\"><a href=\"#15-%EC%82%AD%EC%A0%9C\" aria-label=\"15 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.5 삭제</h2>\n<p>배열의 삭제는 특정 인덱스의 값을 제거하는 과정이다.\n<br/>\n삭제에서는 실제로 삭제가 일어나는 데는 단 한 단계지만, 삭제로 생긴 공간을 없애려면 왼쪽으로 데이터를 이동시키는 단계가 더 필요하다.\n<br/>\n원소 N개를 포함하는 배열에서 삭제에 필요한 최대 단계 수는 N단계이다.</p>\n<h2 id=\"16-집합-단-하나의-규칙이-효율성을-바꾼다\" style=\"position:relative;\"><a href=\"#16-%EC%A7%91%ED%95%A9-%EB%8B%A8-%ED%95%98%EB%82%98%EC%9D%98-%EA%B7%9C%EC%B9%99%EC%9D%B4-%ED%9A%A8%EC%9C%A8%EC%84%B1%EC%9D%84-%EB%B0%94%EA%BE%BC%EB%8B%A4\" aria-label=\"16 집합 단 하나의 규칙이 효율성을 바꾼다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1.6 집합: 단 하나의 규칙이 효율성을 바꾼다.</h2>\n<p>집합: 중복 값을 허용하지 않는 자료 구조다. 집합은 중복 데이터가 없어야 할 때 유용하다.</p>\n<p>집합에서의 삽입은 배열과 다르다. 집합에서는 <strong>먼저 이 값이 이미 집합에 들어 있는지 결정해야 한다.</strong> 중복 데이터를 막는 게 바로 집합의 역할이기 때문이다. 따라서 모든 삽입에는 <strong>검색이 우선이다.</strong></p>\n<p>집합 삽에서 최선의 시나리오네는 원소 N개에 대해 <strong>N+1단계</strong>가 필요하다. 값이 집합에 없음을 확인하는 데 N단계의 검색을, 이어서 실제 삽입에 1단계를 쓰기 때문이다.</p>\n<p>값을 집합의 <strong>맨 앞에</strong> 삽입하는 최악의 시나리오일 때는 컴퓨터 셀 N개를 검색해서 집합이 그 값을 포함하지 않음을 확인한 후, 또 다른 N단계롤 모든 데이터를 오른쪽으로 옮겨야 하며, 마지막 단계에서 새 값을 삽입해야 한다. 총 <strong>2N+1단계</strong>다.</p>","frontmatter":{"title":"자료 구조","date":"August 07, 2021"}}},"pageContext":{"slug":"/알고리즘/자료-구조/","previous":null,"next":{"fields":{"slug":"/알고리즘/알고리즘/"},"frontmatter":{"title":"알고리즘"}}}},"staticQueryHashes":["1210160335","3128451518"]}